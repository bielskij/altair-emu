
./test:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .interp       0000001c  0000000000000238  0000000000000238  00000238  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .note.ABI-tag 00000020  0000000000000254  0000000000000254  00000254  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .note.gnu.build-id 00000024  0000000000000274  0000000000000274  00000274  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .gnu.hash     0000001c  0000000000000298  0000000000000298  00000298  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .dynsym       000000c0  00000000000002b8  00000000000002b8  000002b8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dynstr       0000009f  0000000000000378  0000000000000378  00000378  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .gnu.version  00000010  0000000000000418  0000000000000418  00000418  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .gnu.version_r 00000030  0000000000000428  0000000000000428  00000428  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .rela.dyn     000000c0  0000000000000458  0000000000000458  00000458  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  9 .rela.plt     00000030  0000000000000518  0000000000000518  00000518  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 10 .init         00000017  0000000000000548  0000000000000548  00000548  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 11 .plt          00000030  0000000000000560  0000000000000560  00000560  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .plt.got      00000008  0000000000000590  0000000000000590  00000590  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 13 .text         00000772  00000000000005a0  00000000000005a0  000005a0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 14 .fini         00000009  0000000000000d14  0000000000000d14  00000d14  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 15 .rodata       0000000c  0000000000000d20  0000000000000d20  00000d20  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 16 .eh_frame_hdr 00000214  0000000000000d2c  0000000000000d2c  00000d2c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 17 .eh_frame     00000868  0000000000000f40  0000000000000f40  00000f40  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 18 .init_array   00000008  0000000000201db0  0000000000201db0  00001db0  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 19 .fini_array   00000008  0000000000201db8  0000000000201db8  00001db8  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 20 .dynamic      000001f0  0000000000201dc0  0000000000201dc0  00001dc0  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 21 .got          00000050  0000000000201fb0  0000000000201fb0  00001fb0  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 22 .data         00000010  0000000000202000  0000000000202000  00002000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 23 .bss          00000008  0000000000202010  0000000000202010  00002010  2**0
                  ALLOC
 24 .comment      00000029  0000000000000000  0000000000000000  00002010  2**0
                  CONTENTS, READONLY
 25 .debug_aranges 00000030  0000000000000000  0000000000000000  00002039  2**0
                  CONTENTS, READONLY, DEBUGGING
 26 .debug_info   00000b38  0000000000000000  0000000000000000  00002069  2**0
                  CONTENTS, READONLY, DEBUGGING
 27 .debug_abbrev 000001f4  0000000000000000  0000000000000000  00002ba1  2**0
                  CONTENTS, READONLY, DEBUGGING
 28 .debug_line   000001fc  0000000000000000  0000000000000000  00002d95  2**0
                  CONTENTS, READONLY, DEBUGGING
 29 .debug_str    000004b9  0000000000000000  0000000000000000  00002f91  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .init:

0000000000000548 <_init>:
 548:	48 83 ec 08          	sub    rsp,0x8
 54c:	48 8b 05 95 1a 20 00 	mov    rax,QWORD PTR [rip+0x201a95]        # 201fe8 <__gmon_start__>
 553:	48 85 c0             	test   rax,rax
 556:	74 02                	je     55a <_init+0x12>
 558:	ff d0                	call   rax
 55a:	48 83 c4 08          	add    rsp,0x8
 55e:	c3                   	ret    

Disassembly of section .plt:

0000000000000560 <.plt>:
 560:	ff 35 52 1a 20 00    	push   QWORD PTR [rip+0x201a52]        # 201fb8 <_GLOBAL_OFFSET_TABLE_+0x8>
 566:	ff 25 54 1a 20 00    	jmp    QWORD PTR [rip+0x201a54]        # 201fc0 <_GLOBAL_OFFSET_TABLE_+0x10>
 56c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000000570 <__stack_chk_fail@plt>:
 570:	ff 25 52 1a 20 00    	jmp    QWORD PTR [rip+0x201a52]        # 201fc8 <__stack_chk_fail@GLIBC_2.4>
 576:	68 00 00 00 00       	push   0x0
 57b:	e9 e0 ff ff ff       	jmp    560 <.plt>

0000000000000580 <printf@plt>:
 580:	ff 25 4a 1a 20 00    	jmp    QWORD PTR [rip+0x201a4a]        # 201fd0 <printf@GLIBC_2.2.5>
 586:	68 01 00 00 00       	push   0x1
 58b:	e9 d0 ff ff ff       	jmp    560 <.plt>

Disassembly of section .plt.got:

0000000000000590 <__cxa_finalize@plt>:
 590:	ff 25 62 1a 20 00    	jmp    QWORD PTR [rip+0x201a62]        # 201ff8 <__cxa_finalize@GLIBC_2.2.5>
 596:	66 90                	xchg   ax,ax

Disassembly of section .text:

00000000000005a0 <_start>:
 5a0:	31 ed                	xor    ebp,ebp
 5a2:	49 89 d1             	mov    r9,rdx
 5a5:	5e                   	pop    rsi
 5a6:	48 89 e2             	mov    rdx,rsp
 5a9:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
 5ad:	50                   	push   rax
 5ae:	54                   	push   rsp
 5af:	4c 8d 05 5a 07 00 00 	lea    r8,[rip+0x75a]        # d10 <__libc_csu_fini>
 5b6:	48 8d 0d e3 06 00 00 	lea    rcx,[rip+0x6e3]        # ca0 <__libc_csu_init>
 5bd:	48 8d 3d 91 06 00 00 	lea    rdi,[rip+0x691]        # c55 <main>
 5c4:	ff 15 16 1a 20 00    	call   QWORD PTR [rip+0x201a16]        # 201fe0 <__libc_start_main@GLIBC_2.2.5>
 5ca:	f4                   	hlt    
 5cb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000000005d0 <deregister_tm_clones>:
 5d0:	48 8d 3d 39 1a 20 00 	lea    rdi,[rip+0x201a39]        # 202010 <__TMC_END__>
 5d7:	55                   	push   rbp
 5d8:	48 8d 05 31 1a 20 00 	lea    rax,[rip+0x201a31]        # 202010 <__TMC_END__>
 5df:	48 39 f8             	cmp    rax,rdi
 5e2:	48 89 e5             	mov    rbp,rsp
 5e5:	74 19                	je     600 <deregister_tm_clones+0x30>
 5e7:	48 8b 05 ea 19 20 00 	mov    rax,QWORD PTR [rip+0x2019ea]        # 201fd8 <_ITM_deregisterTMCloneTable>
 5ee:	48 85 c0             	test   rax,rax
 5f1:	74 0d                	je     600 <deregister_tm_clones+0x30>
 5f3:	5d                   	pop    rbp
 5f4:	ff e0                	jmp    rax
 5f6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
 5fd:	00 00 00 
 600:	5d                   	pop    rbp
 601:	c3                   	ret    
 602:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
 606:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
 60d:	00 00 00 

0000000000000610 <register_tm_clones>:
 610:	48 8d 3d f9 19 20 00 	lea    rdi,[rip+0x2019f9]        # 202010 <__TMC_END__>
 617:	48 8d 35 f2 19 20 00 	lea    rsi,[rip+0x2019f2]        # 202010 <__TMC_END__>
 61e:	55                   	push   rbp
 61f:	48 29 fe             	sub    rsi,rdi
 622:	48 89 e5             	mov    rbp,rsp
 625:	48 c1 fe 03          	sar    rsi,0x3
 629:	48 89 f0             	mov    rax,rsi
 62c:	48 c1 e8 3f          	shr    rax,0x3f
 630:	48 01 c6             	add    rsi,rax
 633:	48 d1 fe             	sar    rsi,1
 636:	74 18                	je     650 <register_tm_clones+0x40>
 638:	48 8b 05 b1 19 20 00 	mov    rax,QWORD PTR [rip+0x2019b1]        # 201ff0 <_ITM_registerTMCloneTable>
 63f:	48 85 c0             	test   rax,rax
 642:	74 0c                	je     650 <register_tm_clones+0x40>
 644:	5d                   	pop    rbp
 645:	ff e0                	jmp    rax
 647:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
 64e:	00 00 
 650:	5d                   	pop    rbp
 651:	c3                   	ret    
 652:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
 656:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
 65d:	00 00 00 

0000000000000660 <__do_global_dtors_aux>:
 660:	80 3d a9 19 20 00 00 	cmp    BYTE PTR [rip+0x2019a9],0x0        # 202010 <__TMC_END__>
 667:	75 2f                	jne    698 <__do_global_dtors_aux+0x38>
 669:	48 83 3d 87 19 20 00 	cmp    QWORD PTR [rip+0x201987],0x0        # 201ff8 <__cxa_finalize@GLIBC_2.2.5>
 670:	00 
 671:	55                   	push   rbp
 672:	48 89 e5             	mov    rbp,rsp
 675:	74 0c                	je     683 <__do_global_dtors_aux+0x23>
 677:	48 8b 3d 8a 19 20 00 	mov    rdi,QWORD PTR [rip+0x20198a]        # 202008 <__dso_handle>
 67e:	e8 0d ff ff ff       	call   590 <__cxa_finalize@plt>
 683:	e8 48 ff ff ff       	call   5d0 <deregister_tm_clones>
 688:	c6 05 81 19 20 00 01 	mov    BYTE PTR [rip+0x201981],0x1        # 202010 <__TMC_END__>
 68f:	5d                   	pop    rbp
 690:	c3                   	ret    
 691:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
 698:	f3 c3                	repz ret 
 69a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000006a0 <frame_dummy>:
 6a0:	55                   	push   rbp
 6a1:	48 89 e5             	mov    rbp,rsp
 6a4:	5d                   	pop    rbp
 6a5:	e9 66 ff ff ff       	jmp    610 <register_tm_clones>

00000000000006aa <_onInt>:
typedef struct _Ctx {
	uint8_t flag;
} Ctx;


void _onInt(void *ctx) {
 6aa:	55                   	push   rbp
 6ab:	48 89 e5             	mov    rbp,rsp
 6ae:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi

}
 6b2:	90                   	nop
 6b3:	5d                   	pop    rbp
 6b4:	c3                   	ret    

00000000000006b5 <_anaR>:
	uint8_t   intValue;
	void    (*intHandler)(void *);
} T;


void _anaR() {
 6b5:	55                   	push   rbp
 6b6:	48 89 e5             	mov    rbp,rsp
	__asm(
 6b9:	66 50                	push   ax
 6bb:	08 f8                	or     al,bh
 6bd:	08 d8                	or     al,bl
 6bf:	08 e8                	or     al,ch
 6c1:	08 c8                	or     al,cl
 6c3:	08 f0                	or     al,dh
 6c5:	08 d0                	or     al,dl
 6c7:	08 c0                	or     al,al
 6c9:	24 08                	and    al,0x8
 6cb:	d0 c0                	rol    al,1
 6cd:	40 88 c7             	mov    dil,al
 6d0:	66 58                	pop    ax
 6d2:	20 f8                	and    al,bh
 6d4:	20 d8                	and    al,bl
 6d6:	20 e8                	and    al,ch
 6d8:	20 c8                	and    al,cl
 6da:	20 f0                	and    al,dh
 6dc:	20 d0                	and    al,dl
 6de:	20 c0                	and    al,al
 6e0:	9c                   	pushf  
 6e1:	40 08 3c 24          	or     BYTE PTR [rsp],dil
 6e5:	9d                   	popf   
		"and al, al \t\n"
		"pushf                 \t\n"
		"or BYTE PTR [rsp],dil \t\n"
		"popf                  \t\n"
	);
}
 6e6:	90                   	nop
 6e7:	5d                   	pop    rbp
 6e8:	c3                   	ret    

00000000000006e9 <_anaM>:


void _anaM() {
 6e9:	55                   	push   rbp
 6ea:	48 89 e5             	mov    rbp,rsp
	__asm(
 6ed:	22 45 24             	and    al,BYTE PTR [rbp+0x24]
 6f0:	0a 45 24             	or     al,BYTE PTR [rbp+0x24]
		:
		:
			[off_value] "i" (offsetof (struct _T, intValue))
		:
	);
}
 6f3:	90                   	nop
 6f4:	5d                   	pop    rbp
 6f5:	c3                   	ret    

00000000000006f6 <_ani>:


void _ani() {
 6f6:	55                   	push   rbp
 6f7:	48 89 e5             	mov    rbp,rsp
	__asm(
 6fa:	24 13                	and    al,0x13
		"and al, 0x13 \t\n"
	);
}
 6fc:	90                   	nop
 6fd:	5d                   	pop    rbp
 6fe:	c3                   	ret    

00000000000006ff <_xraR>:


void _xraR() {
 6ff:	55                   	push   rbp
 700:	48 89 e5             	mov    rbp,rsp
	__asm(
 703:	30 f8                	xor    al,bh
 705:	30 d8                	xor    al,bl
 707:	30 e8                	xor    al,ch
 709:	30 c8                	xor    al,cl
 70b:	30 f0                	xor    al,dh
 70d:	30 d0                	xor    al,dl
 70f:	30 c0                	xor    al,al
		"xor al, cl \t\n"
		"xor al, dh \t\n"
		"xor al, dl \t\n"
		"xor al, al \t\n"
	);
}
 711:	90                   	nop
 712:	5d                   	pop    rbp
 713:	c3                   	ret    

0000000000000714 <_xraM>:


void _xraM() {
 714:	55                   	push   rbp
 715:	48 89 e5             	mov    rbp,rsp
	__asm(
 718:	32 45 24             	xor    al,BYTE PTR [rbp+0x24]
		:
		:
			[off_value] "i" (offsetof (struct _T, intValue))
		:
	);
}
 71b:	90                   	nop
 71c:	5d                   	pop    rbp
 71d:	c3                   	ret    

000000000000071e <_xri>:


void _xri() {
 71e:	55                   	push   rbp
 71f:	48 89 e5             	mov    rbp,rsp
	__asm(
 722:	34 13                	xor    al,0x13
		"xor al, 0x13 \t\n"
	);
}
 724:	90                   	nop
 725:	5d                   	pop    rbp
 726:	c3                   	ret    

0000000000000727 <_oraR>:

void _oraR() {
 727:	55                   	push   rbp
 728:	48 89 e5             	mov    rbp,rsp
	__asm(
 72b:	08 f8                	or     al,bh
 72d:	08 d8                	or     al,bl
 72f:	08 e8                	or     al,ch
 731:	08 c8                	or     al,cl
 733:	08 f0                	or     al,dh
 735:	08 d0                	or     al,dl
 737:	08 c0                	or     al,al
		"or al, cl \t\n"
		"or al, dh \t\n"
		"or al, dl \t\n"
		"or al, al \t\n"
	);
}
 739:	90                   	nop
 73a:	5d                   	pop    rbp
 73b:	c3                   	ret    

000000000000073c <_oraM>:


void _oraM() {
 73c:	55                   	push   rbp
 73d:	48 89 e5             	mov    rbp,rsp
	__asm(
 740:	0a 45 24             	or     al,BYTE PTR [rbp+0x24]
		:
		:
			[off_value] "i" (offsetof (struct _T, intValue))
		:
	);
}
 743:	90                   	nop
 744:	5d                   	pop    rbp
 745:	c3                   	ret    

0000000000000746 <_ori>:


void _ori() {
 746:	55                   	push   rbp
 747:	48 89 e5             	mov    rbp,rsp
	__asm(
 74a:	0c 13                	or     al,0x13
		"or al, 0x13 \t\n"
	);
}
 74c:	90                   	nop
 74d:	5d                   	pop    rbp
 74e:	c3                   	ret    

000000000000074f <_subR>:


void _subR() {
 74f:	55                   	push   rbp
 750:	48 89 e5             	mov    rbp,rsp
	__asm(
 753:	28 f8                	sub    al,bh
 755:	28 d8                	sub    al,bl
 757:	28 e8                	sub    al,ch
 759:	28 c8                	sub    al,cl
 75b:	28 f0                	sub    al,dh
 75d:	28 d0                	sub    al,dl
 75f:	28 c0                	sub    al,al
		"sub al, cl \t\n"
		"sub al, dh \t\n"
		"sub al, dl \t\n"
		"sub al, al \t\n"
	);
}
 761:	90                   	nop
 762:	5d                   	pop    rbp
 763:	c3                   	ret    

0000000000000764 <_subM>:

void _subM() {
 764:	55                   	push   rbp
 765:	48 89 e5             	mov    rbp,rsp
	__asm(
 768:	2a 45 24             	sub    al,BYTE PTR [rbp+0x24]
		:
		:
			[off_value] "i" (offsetof (struct _T, intValue))
		:
	);
}
 76b:	90                   	nop
 76c:	5d                   	pop    rbp
 76d:	c3                   	ret    

000000000000076e <_sui>:


void _sui() {
 76e:	55                   	push   rbp
 76f:	48 89 e5             	mov    rbp,rsp
	__asm(
 772:	2c 13                	sub    al,0x13
		"sub al, 0x13 \t\n"
	);
}
 774:	90                   	nop
 775:	5d                   	pop    rbp
 776:	c3                   	ret    

0000000000000777 <_sbbR>:


void _sbbR() {
 777:	55                   	push   rbp
 778:	48 89 e5             	mov    rbp,rsp
	__asm(
 77b:	18 f8                	sbb    al,bh
 77d:	18 d8                	sbb    al,bl
 77f:	18 e8                	sbb    al,ch
 781:	18 c8                	sbb    al,cl
 783:	18 f0                	sbb    al,dh
 785:	18 d0                	sbb    al,dl
 787:	18 c0                	sbb    al,al
		"sbb al, cl \t\n"
		"sbb al, dh \t\n"
		"sbb al, dl \t\n"
		"sbb al, al \t\n"
	);
}
 789:	90                   	nop
 78a:	5d                   	pop    rbp
 78b:	c3                   	ret    

000000000000078c <_sbbM>:

void _sbbM() {
 78c:	55                   	push   rbp
 78d:	48 89 e5             	mov    rbp,rsp
	__asm(
 790:	1a 45 24             	sbb    al,BYTE PTR [rbp+0x24]
		:
		:
			[off_value] "i" (offsetof (struct _T, intValue))
		:
	);
}
 793:	90                   	nop
 794:	5d                   	pop    rbp
 795:	c3                   	ret    

0000000000000796 <_sbi>:


void _sbi() {
 796:	55                   	push   rbp
 797:	48 89 e5             	mov    rbp,rsp
	__asm(
 79a:	1c 13                	sbb    al,0x13
		"sbb al, 0x13 \t\n"
	);
}
 79c:	90                   	nop
 79d:	5d                   	pop    rbp
 79e:	c3                   	ret    

000000000000079f <_adcM>:


void _adcM() {
 79f:	55                   	push   rbp
 7a0:	48 89 e5             	mov    rbp,rsp
	__asm(
 7a3:	12 45 24             	adc    al,BYTE PTR [rbp+0x24]
		:
		:
			[off_value] "i" (offsetof (struct _T, intValue))
		:
	);
}
 7a6:	90                   	nop
 7a7:	5d                   	pop    rbp
 7a8:	c3                   	ret    

00000000000007a9 <_addM>:


void _addM() {
 7a9:	55                   	push   rbp
 7aa:	48 89 e5             	mov    rbp,rsp
	__asm(
 7ad:	02 45 24             	add    al,BYTE PTR [rbp+0x24]
		:
		:
			[off_value] "i" (offsetof (struct _T, intValue))
		:
	);
}
 7b0:	90                   	nop
 7b1:	5d                   	pop    rbp
 7b2:	c3                   	ret    

00000000000007b3 <_addR>:

void _addR() {
 7b3:	55                   	push   rbp
 7b4:	48 89 e5             	mov    rbp,rsp
	__asm(
 7b7:	00 f8                	add    al,bh
 7b9:	00 d8                	add    al,bl
 7bb:	00 e8                	add    al,ch
 7bd:	00 c8                	add    al,cl
 7bf:	00 f0                	add    al,dh
 7c1:	00 d0                	add    al,dl
 7c3:	00 c0                	add    al,al
		"add al, cl \t\n"
		"add al, dh \t\n"
		"add al, dl \t\n"
		"add al, al \t\n"
	);
}
 7c5:	90                   	nop
 7c6:	5d                   	pop    rbp
 7c7:	c3                   	ret    

00000000000007c8 <_adcR>:


void _adcR() {
 7c8:	55                   	push   rbp
 7c9:	48 89 e5             	mov    rbp,rsp
	__asm(
 7cc:	10 f8                	adc    al,bh
 7ce:	10 d8                	adc    al,bl
 7d0:	10 e8                	adc    al,ch
 7d2:	10 c8                	adc    al,cl
 7d4:	10 f0                	adc    al,dh
 7d6:	10 d0                	adc    al,dl
 7d8:	10 c0                	adc    al,al
		"adc al, cl \t\n"
		"adc al, dh \t\n"
		"adc al, dl \t\n"
		"adc al, al \t\n"
	);
}
 7da:	90                   	nop
 7db:	5d                   	pop    rbp
 7dc:	c3                   	ret    

00000000000007dd <_xchg>:


void _xchg() {
 7dd:	55                   	push   rbp
 7de:	48 89 e5             	mov    rbp,rsp
	__asm(
 7e1:	9c                   	pushf  
 7e2:	30 ee                	xor    dh,ch
 7e4:	30 f5                	xor    ch,dh
 7e6:	30 ee                	xor    dh,ch
 7e8:	30 ca                	xor    dl,cl
 7ea:	30 d1                	xor    cl,dl
 7ec:	30 ca                	xor    dl,cl
 7ee:	9d                   	popf   
		"xor dl, cl \t\n"
		"xor cl, dl \t\n"
		"xor dl, cl \t\n"
		"popf       \t\n"
	);
}
 7ef:	90                   	nop
 7f0:	5d                   	pop    rbp
 7f1:	c3                   	ret    

00000000000007f2 <_inrM>:

void _inrM() {
 7f2:	55                   	push   rbp
 7f3:	48 89 e5             	mov    rbp,rsp
	__asm(
 7f6:	fe 45 24             	inc    BYTE PTR [rbp+0x24]
		:
		:
			[off_value] "i" (offsetof (struct _T, intValue))
		:
	);
}
 7f9:	90                   	nop
 7fa:	5d                   	pop    rbp
 7fb:	c3                   	ret    

00000000000007fc <_dcrM>:

void _dcrM() {
 7fc:	55                   	push   rbp
 7fd:	48 89 e5             	mov    rbp,rsp
	__asm(
 800:	fe 4d 24             	dec    BYTE PTR [rbp+0x24]
		:
		:
			[off_value] "i" (offsetof (struct _T, intValue))
		:
	);
}
 803:	90                   	nop
 804:	5d                   	pop    rbp
 805:	c3                   	ret    

0000000000000806 <_lhld>:


void _lhld() {
 806:	55                   	push   rbp
 807:	48 89 e5             	mov    rbp,rsp
	__asm(
 80a:	8a 75 24             	mov    dh,BYTE PTR [rbp+0x24]
 80d:	8a 55 24             	mov    dl,BYTE PTR [rbp+0x24]
		:
		:
			[off_value] "i" (offsetof (struct _T, intValue))
		:
	);
}
 810:	90                   	nop
 811:	5d                   	pop    rbp
 812:	c3                   	ret    

0000000000000813 <_cpi>:

void _cpi() {
 813:	55                   	push   rbp
 814:	48 89 e5             	mov    rbp,rsp
	__asm(
 817:	3a 45 24             	cmp    al,BYTE PTR [rbp+0x24]
		:
		:
			[off_value] "i" (offsetof (struct _T, intValue))
		:
	);
}
 81a:	90                   	nop
 81b:	5d                   	pop    rbp
 81c:	c3                   	ret    

000000000000081d <_cmp>:

void _cmp() {
 81d:	55                   	push   rbp
 81e:	48 89 e5             	mov    rbp,rsp
	__asm(
 821:	38 f8                	cmp    al,bh
 823:	38 d8                	cmp    al,bl
 825:	38 e8                	cmp    al,ch
 827:	38 c8                	cmp    al,cl
 829:	38 f0                	cmp    al,dh
 82b:	38 d0                	cmp    al,dl
 82d:	38 c0                	cmp    al,al
		"cmp al, cl \t\n"
		"cmp al, dh \t\n"
		"cmp al, dl \t\n"
		"cmp al, al \t\n"
	);
}
 82f:	90                   	nop
 830:	5d                   	pop    rbp
 831:	c3                   	ret    

0000000000000832 <_sbb>:


void _sbb() {
 832:	55                   	push   rbp
 833:	48 89 e5             	mov    rbp,rsp
	__asm(
 836:	18 f8                	sbb    al,bh
 838:	18 d8                	sbb    al,bl
 83a:	18 e8                	sbb    al,ch
 83c:	18 c8                	sbb    al,cl
 83e:	18 f0                	sbb    al,dh
 840:	18 d0                	sbb    al,dl
 842:	18 c0                	sbb    al,al
		"sbb al, cl \t\n"
		"sbb al, dh \t\n"
		"sbb al, dl \t\n"
		"sbb al, al \t\n"
	);
}
 844:	90                   	nop
 845:	5d                   	pop    rbp
 846:	c3                   	ret    

0000000000000847 <_incR>:

void _incR() {
 847:	55                   	push   rbp
 848:	48 89 e5             	mov    rbp,rsp
	__asm(
 84b:	fe c7                	inc    bh
 84d:	fe c3                	inc    bl
 84f:	fe c5                	inc    ch
 851:	fe c1                	inc    cl
 853:	fe c6                	inc    dh
 855:	fe c2                	inc    dl
 857:	fe c0                	inc    al
		"inc al \t\n"
		:
		:
		:
	);
}
 859:	90                   	nop
 85a:	5d                   	pop    rbp
 85b:	c3                   	ret    

000000000000085c <_dcr>:

void _dcr() {
 85c:	55                   	push   rbp
 85d:	48 89 e5             	mov    rbp,rsp
	__asm(
 860:	9c                   	pushf  
 861:	40 8a 3c 24          	mov    dil,BYTE PTR [rsp]
 865:	9d                   	popf   
 866:	40 80 e7 01          	and    dil,0x1
 86a:	80 c7 ff             	add    bh,0xff
 86d:	80 c3 ff             	add    bl,0xff
 870:	80 c5 ff             	add    ch,0xff
 873:	80 c1 ff             	add    cl,0xff
 876:	80 c6 ff             	add    dh,0xff
 879:	80 c2 ff             	add    dl,0xff
 87c:	04 ff                	add    al,0xff
 87e:	9c                   	pushf  
 87f:	80 24 24 fe          	and    BYTE PTR [rsp],0xfe
 883:	40 08 3c 24          	or     BYTE PTR [rsp],dil
 887:	9d                   	popf   
//		"dec al \t\n"
//		:
//		:
//		:
//	);
}
 888:	90                   	nop
 889:	5d                   	pop    rbp
 88a:	c3                   	ret    

000000000000088b <_daa>:

void _daa() {
 88b:	55                   	push   rbp
 88c:	48 89 e5             	mov    rbp,rsp
	__asm(
 88f:	66 53                	push   bx
 891:	66 51                	push   cx
 893:	66 52                	push   dx
 895:	9c                   	pushf  
 896:	66 5b                	pop    bx
 898:	66 31 c9             	xor    cx,cx
 89b:	88 c1                	mov    cl,al
 89d:	88 da                	mov    dl,bl
 89f:	40 88 c7             	mov    dil,al
 8a2:	40 80 e7 0f          	and    dil,0xf
 8a6:	40 80 ff 09          	cmp    dil,0x9
 8aa:	7f 07                	jg     8b3 <lo_ovf>
 8ac:	f6 c3 10             	test   bl,0x10
 8af:	75 02                	jne    8b3 <lo_ovf>
 8b1:	eb 11                	jmp    8c4 <lo_not_ovf>

00000000000008b3 <lo_ovf>:
 8b3:	04 06                	add    al,0x6
 8b5:	9c                   	pushf  
 8b6:	66 5f                	pop    di
 8b8:	40 80 e7 01          	and    dil,0x1
 8bc:	40 08 fa             	or     dl,dil
 8bf:	80 ca 10             	or     dl,0x10
 8c2:	eb 03                	jmp    8c7 <hi_check>

00000000000008c4 <lo_not_ovf>:
 8c4:	80 e2 ef             	and    dl,0xef

00000000000008c7 <hi_check>:
 8c7:	66 81 f9 99 00       	cmp    cx,0x99
 8cc:	7f 07                	jg     8d5 <hi_ovf>
 8ce:	f6 c3 01             	test   bl,0x1
 8d1:	75 02                	jne    8d5 <hi_ovf>
 8d3:	eb 07                	jmp    8dc <hi_not_ovf>

00000000000008d5 <hi_ovf>:
 8d5:	04 60                	add    al,0x60
 8d7:	80 ca 01             	or     dl,0x1
 8da:	eb 03                	jmp    8df <finished>

00000000000008dc <hi_not_ovf>:
 8dc:	80 e2 fe             	and    dl,0xfe

00000000000008df <finished>:
 8df:	88 d3                	mov    bl,dl
 8e1:	66 53                	push   bx
 8e3:	9d                   	popf   
 8e4:	66 5a                	pop    dx
 8e6:	66 59                	pop    cx
 8e8:	66 5b                	pop    bx
		"  popf         \t\n"
		"  pop dx       \t\n"
		"  pop cx       \t\n"
		"  pop bx       \t\n"
	);
}
 8ea:	90                   	nop
 8eb:	5d                   	pop    rbp
 8ec:	c3                   	ret    

00000000000008ed <_ctc>:


void _ctc() {
 8ed:	55                   	push   rbp
 8ee:	48 89 e5             	mov    rbp,rsp
	__asm("cmc");
 8f1:	f5                   	cmc    
}
 8f2:	90                   	nop
 8f3:	5d                   	pop    rbp
 8f4:	c3                   	ret    

00000000000008f5 <_stc>:

void _stc() {
 8f5:	55                   	push   rbp
 8f6:	48 89 e5             	mov    rbp,rsp
	__asm("stc");
 8f9:	f9                   	stc    
}
 8fa:	90                   	nop
 8fb:	5d                   	pop    rbp
 8fc:	c3                   	ret    

00000000000008fd <_inx>:

void _inx() {
 8fd:	55                   	push   rbp
 8fe:	48 89 e5             	mov    rbp,rsp
	__asm(
 901:	66 ff c3             	inc    bx
 904:	66 ff c1             	inc    cx
 907:	66 ff c2             	inc    dx
 90a:	66 ff c6             	inc    si
		"inc bx \t\n"
		"inc cx \t\n"
		"inc dx \t\n"
		"inc si \t\n"
	);
}
 90d:	90                   	nop
 90e:	5d                   	pop    rbp
 90f:	c3                   	ret    

0000000000000910 <_dcx>:


void _dcx() {
 910:	55                   	push   rbp
 911:	48 89 e5             	mov    rbp,rsp
	__asm(
 914:	66 ff cb             	dec    bx
 917:	66 ff c9             	dec    cx
 91a:	66 ff ca             	dec    dx
 91d:	66 ff ce             	dec    si
		"dec bx \t\n"
		"dec cx \t\n"
		"dec dx \t\n"
		"dec si \t\n"
	);
}
 920:	90                   	nop
 921:	5d                   	pop    rbp
 922:	c3                   	ret    

0000000000000923 <_dad>:


void _dad() {
 923:	55                   	push   rbp
 924:	48 89 e5             	mov    rbp,rsp
	__asm(
 927:	9c                   	pushf  
 928:	66 01 da             	add    dx,bx
 92b:	66 01 ca             	add    dx,cx
 92e:	66 01 d2             	add    dx,dx
 931:	66 01 f2             	add    dx,si
 934:	9c                   	pushf  
 935:	40 b7 01             	mov    dil,0x1
 938:	40 22 3c 24          	and    dil,BYTE PTR [rsp]
 93c:	9d                   	popf   
 93d:	80 24 24 fe          	and    BYTE PTR [rsp],0xfe
 941:	40 08 3c 24          	or     BYTE PTR [rsp],dil
 945:	9d                   	popf   
		"and byte ptr [rsp], 0xfe \t\n"
		"or  byte ptr [rsp], dil   \t\n"

		"popf  \t\n"
	);
}
 946:	90                   	nop
 947:	5d                   	pop    rbp
 948:	c3                   	ret    

0000000000000949 <_ret>:


void _ret() {
 949:	55                   	push   rbp
 94a:	48 89 e5             	mov    rbp,rsp
	__asm(
 94d:	9c                   	pushf  
 94e:	50                   	push   rax
 94f:	8a 45 24             	mov    al,BYTE PTR [rbp+0x24]
 952:	66 ff c6             	inc    si
 955:	8a 65 24             	mov    ah,BYTE PTR [rbp+0x24]
 958:	66 ff c6             	inc    si
 95b:	66 89 45 0c          	mov    WORD PTR [rbp+0xc],ax
 95f:	58                   	pop    rax
 960:	9d                   	popf   
 961:	40 b7 0a             	mov    dil,0xa
			:
				[off_value]  "i" (offsetof (struct _T, intValue)),
				[off_pc]  "i" (offsetof (struct _T, PC))
			:
		);
}
 964:	90                   	nop
 965:	5d                   	pop    rbp
 966:	c3                   	ret    

0000000000000967 <_pushpop>:


void _pushpop() {
 967:	55                   	push   rbp
 968:	48 89 e5             	mov    rbp,rsp
	__asm(
 96b:	8a 7d 24             	mov    bh,BYTE PTR [rbp+0x24]
 96e:	8a 5d 24             	mov    bl,BYTE PTR [rbp+0x24]
 971:	8a 6d 24             	mov    ch,BYTE PTR [rbp+0x24]
 974:	8a 4d 24             	mov    cl,BYTE PTR [rbp+0x24]
 977:	8a 75 24             	mov    dh,BYTE PTR [rbp+0x24]
 97a:	8a 55 24             	mov    dl,BYTE PTR [rbp+0x24]
 97d:	8a 45 24             	mov    al,BYTE PTR [rbp+0x24]
 980:	66 ff ce             	dec    si
 983:	66 ff c6             	inc    si
 986:	9c                   	pushf  
 987:	40 8a 7d 24          	mov    dil,BYTE PTR [rbp+0x24]
 98b:	80 24 24 d5          	and    BYTE PTR [rsp],0xd5
 98f:	40 08 3c 24          	or     BYTE PTR [rsp],dil
 993:	9d                   	popf   
 994:	40 88 7d 04          	mov    BYTE PTR [rbp+0x4],dil
 998:	40 8a 7d 04          	mov    dil,BYTE PTR [rbp+0x4]
 99c:	40 88 7d 24          	mov    BYTE PTR [rbp+0x24],dil
		:
			[off_value]  "i" (offsetof (struct _T, intValue)),
			[off_f]      "i" (offsetof (struct _T, F))
		:
	);
}
 9a0:	90                   	nop
 9a1:	5d                   	pop    rbp
 9a2:	c3                   	ret    

00000000000009a3 <_clrCarry>:


void _clrCarry() {
 9a3:	55                   	push   rbp
 9a4:	48 89 e5             	mov    rbp,rsp
	__asm(
 9a7:	9c                   	pushf  
 9a8:	80 24 24 ee          	and    BYTE PTR [rsp],0xee
 9ac:	9d                   	popf   
		"pushf \t\n"
		"and    BYTE PTR [rsp],0xee \t\n"
		"popf  \t\n"
	);
}
 9ad:	90                   	nop
 9ae:	5d                   	pop    rbp
 9af:	c3                   	ret    

00000000000009b0 <_lxi>:

void _lxi() {
 9b0:	55                   	push   rbp
 9b1:	48 89 e5             	mov    rbp,rsp
	__asm(
 9b4:	66 bb 34 12          	mov    bx,0x1234
 9b8:	66 b9 34 12          	mov    cx,0x1234
 9bc:	66 ba 34 12          	mov    dx,0x1234
 9c0:	66 be 34 12          	mov    si,0x1234
		"mov bx, 0x1234 \t\n"
		"mov cx, 0x1234 \t\n"
		"mov dx, 0x1234 \t\n"
		"mov si, 0x1234 \t\n"
	);
}
 9c4:	90                   	nop
 9c5:	5d                   	pop    rbp
 9c6:	c3                   	ret    

00000000000009c7 <_checkint>:

void _checkint() {
 9c7:	55                   	push   rbp
 9c8:	48 89 e5             	mov    rbp,rsp
	__asm(
 9cb:	f6 45 10 01          	test   BYTE PTR [rbp+0x10],0x1
 9cf:	74 01                	je     9d2 <noint>
 9d1:	c3                   	ret    

00000000000009d2 <noint>:
 9d2:	90                   	nop
		:
		:
			[off_int]  "i" (offsetof (struct _T, intFF))
		:
	);
}
 9d3:	90                   	nop
 9d4:	5d                   	pop    rbp
 9d5:	c3                   	ret    

00000000000009d6 <_io>:


void _io() {
 9d6:	55                   	push   rbp
 9d7:	48 89 e5             	mov    rbp,rsp
	__asm(
 9da:	40 8a 7d 24          	mov    dil,BYTE PTR [rbp+0x24]
 9de:	40 88 7d 22          	mov    BYTE PTR [rbp+0x22],dil
 9e2:	66 c7 45 22 34 12    	mov    WORD PTR [rbp+0x22],0x1234
 9e8:	8a 45 22             	mov    al,BYTE PTR [rbp+0x22]
		:
			[off_address]  "i" (offsetof (struct _T, intAddress)),
			[off_value]    "i" (offsetof (struct _T, intValue))
		:
	);
}
 9eb:	90                   	nop
 9ec:	5d                   	pop    rbp
 9ed:	c3                   	ret    

00000000000009ee <_saveFlags>:


void _saveFlags() {
 9ee:	55                   	push   rbp
 9ef:	48 89 e5             	mov    rbp,rsp
	__asm(
 9f2:	9c                   	pushf  
 9f3:	66 58                	pop    ax
 9f5:	24 d5                	and    al,0xd5
 9f7:	88 45 04             	mov    BYTE PTR [rbp+0x4],al
 9fa:	48 83 c4 06          	add    rsp,0x6
		:
		:
			[off_f]  "i" (offsetof (struct _T, F))
		:
	);
}
 9fe:	90                   	nop
 9ff:	5d                   	pop    rbp
 a00:	c3                   	ret    

0000000000000a01 <_loadFlags>:


void _loadFlags() {
 a01:	55                   	push   rbp
 a02:	48 89 e5             	mov    rbp,rsp
	__asm(
 a05:	9c                   	pushf  
 a06:	66 58                	pop    ax
 a08:	66 25 2a ff          	and    ax,0xff2a
 a0c:	0a 45 04             	or     al,BYTE PTR [rbp+0x4]
 a0f:	66 50                	push   ax
 a11:	9d                   	popf   
		:
		:
			[off_f]  "i" (offsetof (struct _T, F))
		:
	);
}
 a12:	90                   	nop
 a13:	5d                   	pop    rbp
 a14:	c3                   	ret    

0000000000000a15 <_rrc>:


void _rrc() {
 a15:	55                   	push   rbp
 a16:	48 89 e5             	mov    rbp,rsp
	__asm(
 a19:	9c                   	pushf  
 a1a:	d0 c8                	ror    al,1
 a1c:	a8 80                	test   al,0x80
 a1e:	75 06                	jne    a26 <isset>
 a20:	80 24 24 fe          	and    BYTE PTR [rsp],0xfe
 a24:	eb 04                	jmp    a2a <done>

0000000000000a26 <isset>:
 a26:	80 0c 24 01          	or     BYTE PTR [rsp],0x1

0000000000000a2a <done>:
 a2a:	9d                   	popf   
		"isset:                     \t\n"
		"  or byte ptr [rsp], 0x01  \t\n"
		"done:                      \t\n"
		"popfq                      \t\n"
	);
}
 a2b:	90                   	nop
 a2c:	5d                   	pop    rbp
 a2d:	c3                   	ret    

0000000000000a2e <_rrl>:

void _rrl() {
 a2e:	55                   	push   rbp
 a2f:	48 89 e5             	mov    rbp,rsp
	__asm(
 a32:	9c                   	pushf  
 a33:	d0 c0                	rol    al,1
 a35:	a8 80                	test   al,0x80
 a37:	75 06                	jne    a3f <isset_rrl>
 a39:	80 24 24 fe          	and    BYTE PTR [rsp],0xfe
 a3d:	eb 04                	jmp    a43 <done_rrl>

0000000000000a3f <isset_rrl>:
 a3f:	80 0c 24 01          	or     BYTE PTR [rsp],0x1

0000000000000a43 <done_rrl>:
 a43:	9d                   	popf   
		"isset_rrl:                 \t\n"
		"  or byte ptr [rsp], 0x01  \t\n"
		"done_rrl:                  \t\n"
		"popfq                      \t\n"
	);
}
 a44:	90                   	nop
 a45:	5d                   	pop    rbp
 a46:	c3                   	ret    

0000000000000a47 <ralr>:

void ralr() {
 a47:	55                   	push   rbp
 a48:	48 89 e5             	mov    rbp,rsp
	__asm(
 a4b:	d0 d8                	rcr    al,1
 a4d:	d0 d0                	rcl    al,1
		"rcr al, 1 \t\n"
		"rcl al, 1 \t\n"
	);
}
 a4f:	90                   	nop
 a50:	5d                   	pop    rbp
 a51:	c3                   	ret    

0000000000000a52 <cma>:

void cma() {
 a52:	55                   	push   rbp
 a53:	48 89 e5             	mov    rbp,rsp
	__asm(
 a56:	9c                   	pushf  
 a57:	34 ff                	xor    al,0xff
 a59:	9d                   	popf   
		"pushf \t\n"
		"xor al, 0xff \t\n"
		"popf \t\n"
	);
}
 a5a:	90                   	nop
 a5b:	5d                   	pop    rbp
 a5c:	c3                   	ret    

0000000000000a5d <_xthl>:


void _xthl() {
 a5d:	55                   	push   rbp
 a5e:	48 89 e5             	mov    rbp,rsp
	__asm(
 a61:	66 89 d7             	mov    di,dx
 a64:	40 88 7d 24          	mov    BYTE PTR [rbp+0x24],dil
 a68:	66 ff 45 22          	inc    WORD PTR [rbp+0x22]
 a6c:	8a 75 24             	mov    dh,BYTE PTR [rbp+0x24]
 a6f:	8a 55 24             	mov    dl,BYTE PTR [rbp+0x24]
 a72:	66 c1 cf 08          	ror    di,0x8
		:
			[off_intValue]    "i" (offsetof (struct _T, intValue)),
			[off_intAddress]  "i" (offsetof (struct _T, intAddress))
		:
	);
}
 a76:	90                   	nop
 a77:	5d                   	pop    rbp
 a78:	c3                   	ret    

0000000000000a79 <_sphl>:


void _sphl() {
 a79:	55                   	push   rbp
 a7a:	48 89 e5             	mov    rbp,rsp
	__asm(
 a7d:	66 89 d6             	mov    si,dx
		"mov si, dx\t\n"
	);
}
 a80:	90                   	nop
 a81:	5d                   	pop    rbp
 a82:	c3                   	ret    

0000000000000a83 <_pchl>:

void _pchl() {
 a83:	55                   	push   rbp
 a84:	48 89 e5             	mov    rbp,rsp
	__asm(
 a87:	66 89 55 0c          	mov    WORD PTR [rbp+0xc],dx
		:
		:
			[off_pc]  "i" (offsetof (struct _T, PC))
		:
	);
}
 a8b:	90                   	nop
 a8c:	5d                   	pop    rbp
 a8d:	c3                   	ret    

0000000000000a8e <_adi>:


void _adi() {
 a8e:	55                   	push   rbp
 a8f:	48 89 e5             	mov    rbp,rsp
	__asm(
 a92:	04 13                	add    al,0x13
		"add al, 0x13 \t\n"
	);
}
 a94:	90                   	nop
 a95:	5d                   	pop    rbp
 a96:	c3                   	ret    

0000000000000a97 <_aci>:

void _aci() {
 a97:	55                   	push   rbp
 a98:	48 89 e5             	mov    rbp,rsp
	__asm(
 a9b:	14 13                	adc    al,0x13
		"adc al, 0x13 \t\n"
	);
}
 a9d:	90                   	nop
 a9e:	5d                   	pop    rbp
 a9f:	c3                   	ret    

0000000000000aa0 <_movrr>:

void _movrr() {
 aa0:	55                   	push   rbp
 aa1:	48 89 e5             	mov    rbp,rsp
	__asm(
 aa4:	88 ff                	mov    bh,bh
 aa6:	88 df                	mov    bh,bl
 aa8:	88 ef                	mov    bh,ch
 aaa:	88 cf                	mov    bh,cl
 aac:	88 f7                	mov    bh,dh
 aae:	88 d7                	mov    bh,dl
 ab0:	88 c7                	mov    bh,al
 ab2:	88 fb                	mov    bl,bh
 ab4:	88 db                	mov    bl,bl
 ab6:	88 eb                	mov    bl,ch
 ab8:	88 cb                	mov    bl,cl
 aba:	88 f3                	mov    bl,dh
 abc:	88 d3                	mov    bl,dl
 abe:	88 c3                	mov    bl,al
 ac0:	88 fd                	mov    ch,bh
 ac2:	88 dd                	mov    ch,bl
 ac4:	88 ed                	mov    ch,ch
 ac6:	88 cd                	mov    ch,cl
 ac8:	88 f5                	mov    ch,dh
 aca:	88 d5                	mov    ch,dl
 acc:	88 c5                	mov    ch,al
 ace:	88 f9                	mov    cl,bh
 ad0:	88 d9                	mov    cl,bl
 ad2:	88 e9                	mov    cl,ch
 ad4:	88 c9                	mov    cl,cl
 ad6:	88 f1                	mov    cl,dh
 ad8:	88 d1                	mov    cl,dl
 ada:	88 c1                	mov    cl,al
 adc:	88 fe                	mov    dh,bh
 ade:	88 de                	mov    dh,bl
 ae0:	88 ee                	mov    dh,ch
 ae2:	88 ce                	mov    dh,cl
 ae4:	88 f6                	mov    dh,dh
 ae6:	88 d6                	mov    dh,dl
 ae8:	88 c6                	mov    dh,al
 aea:	88 fa                	mov    dl,bh
 aec:	88 da                	mov    dl,bl
 aee:	88 ea                	mov    dl,ch
 af0:	88 ca                	mov    dl,cl
 af2:	88 f2                	mov    dl,dh
 af4:	88 d2                	mov    dl,dl
 af6:	88 c2                	mov    dl,al
 af8:	88 f8                	mov    al,bh
 afa:	88 d8                	mov    al,bl
 afc:	88 e8                	mov    al,ch
 afe:	88 c8                	mov    al,cl
 b00:	88 f0                	mov    al,dh
 b02:	88 d0                	mov    al,dl
 b04:	88 c0                	mov    al,al
		"mov al,cl  \t\n"
		"mov al,dh  \t\n"
		"mov al,dl  \t\n"
		"mov al,al  \t\n"
	);
}
 b06:	90                   	nop
 b07:	5d                   	pop    rbp
 b08:	c3                   	ret    

0000000000000b09 <movRM>:


void movRM() {
 b09:	55                   	push   rbp
 b0a:	48 89 e5             	mov    rbp,rsp
	__asm (
 b0d:	8a 7d 24             	mov    bh,BYTE PTR [rbp+0x24]
 b10:	8a 5d 24             	mov    bl,BYTE PTR [rbp+0x24]
 b13:	8a 6d 24             	mov    ch,BYTE PTR [rbp+0x24]
 b16:	8a 4d 24             	mov    cl,BYTE PTR [rbp+0x24]
 b19:	8a 75 24             	mov    dh,BYTE PTR [rbp+0x24]
 b1c:	8a 55 24             	mov    dl,BYTE PTR [rbp+0x24]
 b1f:	8a 45 24             	mov    al,BYTE PTR [rbp+0x24]
		:
		:
			[off_value]  "i" (offsetof (struct _T, intValue))
		:
	);
}
 b22:	90                   	nop
 b23:	5d                   	pop    rbp
 b24:	c3                   	ret    

0000000000000b25 <movMR>:

void movMR() {
 b25:	55                   	push   rbp
 b26:	48 89 e5             	mov    rbp,rsp
	__asm (
 b29:	88 7d 24             	mov    BYTE PTR [rbp+0x24],bh
 b2c:	88 5d 24             	mov    BYTE PTR [rbp+0x24],bl
 b2f:	88 6d 24             	mov    BYTE PTR [rbp+0x24],ch
 b32:	88 4d 24             	mov    BYTE PTR [rbp+0x24],cl
 b35:	88 75 24             	mov    BYTE PTR [rbp+0x24],dh
 b38:	88 55 24             	mov    BYTE PTR [rbp+0x24],dl
 b3b:	88 45 24             	mov    BYTE PTR [rbp+0x24],al
		:
		:
			[off_value]  "i" (offsetof (struct _T, intValue))
		:
	);
}
 b3e:	90                   	nop
 b3f:	5d                   	pop    rbp
 b40:	c3                   	ret    

0000000000000b41 <_jmp>:


void _jmp() {
 b41:	55                   	push   rbp
 b42:	48 89 e5             	mov    rbp,rsp
	__asm (
 b45:	72 08                	jb     b4f <z_false>
 b47:	66 c7 45 0c 34 12    	mov    WORD PTR [rbp+0xc],0x1234
 b4d:	eb 07                	jmp    b56 <done_jmp>

0000000000000b4f <z_false>:
 b4f:	9c                   	pushf  
 b50:	66 83 45 0c 03       	add    WORD PTR [rbp+0xc],0x3
 b55:	9d                   	popf   

0000000000000b56 <done_jmp>:
 b56:	90                   	nop
		:
		:
			[off_pc] "i" (offsetof (struct _T, PC))
		:
	);
}
 b57:	90                   	nop
 b58:	5d                   	pop    rbp
 b59:	c3                   	ret    

0000000000000b5a <nexti>:

void nexti(void *data, uint8_t ticks) {
 b5a:	55                   	push   rbp
 b5b:	48 89 e5             	mov    rbp,rsp
 b5e:	48 83 ec 50          	sub    rsp,0x50
 b62:	48 89 7d b8          	mov    QWORD PTR [rbp-0x48],rdi
 b66:	89 f0                	mov    eax,esi
 b68:	88 45 b4             	mov    BYTE PTR [rbp-0x4c],al
 b6b:	64 48 8b 04 25 28 00 	mov    rax,QWORD PTR fs:0x28
 b72:	00 00 
 b74:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
 b78:	31 c0                	xor    eax,eax
	// execute int callback
	{
		__asm(
 b7a:	66 89 5d 22          	mov    WORD PTR [rbp+0x22],bx
 b7e:	66 89 4d 22          	mov    WORD PTR [rbp+0x22],cx
 b82:	66 89 55 22          	mov    WORD PTR [rbp+0x22],dx
 b86:	66 89 75 22          	mov    WORD PTR [rbp+0x22],si
		);

//		[off_address]  "i" (offsetof (struct _T, intAddress)),
//		[off_value]    "i" (offsetof (struct _T, intValue)),

		__asm(
 b8a:	50                   	push   rax
 b8b:	b0 02                	mov    al,0x2
 b8d:	88 45 20             	mov    BYTE PTR [rbp+0x20],al
 b90:	48 8b 45 28          	mov    rax,QWORD PTR [rbp+0x28]
 b94:	51                   	push   rcx
 b95:	52                   	push   rdx
 b96:	56                   	push   rsi
 b97:	57                   	push   rdi
 b98:	41 50                	push   r8
 b9a:	41 51                	push   r9
 b9c:	41 52                	push   r10
 b9e:	41 53                	push   r11
 ba0:	48 89 ef             	mov    rdi,rbp
 ba3:	ff d0                	call   rax
 ba5:	41 5b                	pop    r11
 ba7:	41 5a                	pop    r10
 ba9:	41 59                	pop    r9
 bab:	41 58                	pop    r8
 bad:	5f                   	pop    rdi
 bae:	5e                   	pop    rsi
 baf:	5a                   	pop    rdx
 bb0:	59                   	pop    rcx
 bb1:	58                   	pop    rax
				[off_hndlr]    "i" (offsetof (struct _T, intHandler))
			:
		);
	}

	__asm(
 bb2:	57                   	push   rdi
 bb3:	48 89 ef             	mov    rdi,rbp
 bb6:	5f                   	pop    rdi

	// PC = PC + 2
	{
		T t;

		t.PC = 2;
 bb7:	66 c7 45 cc 02 00    	mov    WORD PTR [rbp-0x34],0x2

		__asm (
 bbd:	48 8d 45 c0          	lea    rax,[rbp-0x40]
 bc1:	55                   	push   rbp
 bc2:	48 89 c5             	mov    rbp,rax
 bc5:	50                   	push   rax
 bc6:	66 8b 45 0c          	mov    ax,WORD PTR [rbp+0xc]
 bca:	66 83 c0 02          	add    ax,0x2
 bce:	66 89 45 0c          	mov    WORD PTR [rbp+0xc],ax
 bd2:	58                   	pop    rax
 bd3:	5d                   	pop    rbp
				"a" (&t),
				[off_pc] "i" (offsetof (struct _T, PC))
			:
		);

		printf("PC: %u\n", t.PC);
 bd4:	0f b7 45 cc          	movzx  eax,WORD PTR [rbp-0x34]
 bd8:	0f b7 c0             	movzx  eax,ax
 bdb:	89 c6                	mov    esi,eax
 bdd:	48 8d 3d 40 01 00 00 	lea    rdi,[rip+0x140]        # d24 <_IO_stdin_used+0x4>
 be4:	b8 00 00 00 00       	mov    eax,0x0
 be9:	e8 92 f9 ff ff       	call   580 <printf@plt>
	}
}
 bee:	90                   	nop
 bef:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
 bf3:	64 48 33 04 25 28 00 	xor    rax,QWORD PTR fs:0x28
 bfa:	00 00 
 bfc:	74 05                	je     c03 <nexti+0xa9>
 bfe:	e8 6d f9 ff ff       	call   570 <__stack_chk_fail@plt>
 c03:	c9                   	leave  
 c04:	c3                   	ret    

0000000000000c05 <readByte>:


uint8_t readByte(void *data, uint16_t address) {
 c05:	55                   	push   rbp
 c06:	48 89 e5             	mov    rbp,rsp
 c09:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
 c0d:	89 f0                	mov    eax,esi
 c0f:	66 89 45 f4          	mov    WORD PTR [rbp-0xc],ax
	return 123;
 c13:	b8 7b 00 00 00       	mov    eax,0x7b
}
 c18:	5d                   	pop    rbp
 c19:	c3                   	ret    

0000000000000c1a <runCode>:

void runCode(uint16_t *regs, void (*tickCallback)(void *data), void *data) {
 c1a:	55                   	push   rbp
 c1b:	48 89 e5             	mov    rbp,rsp
 c1e:	48 83 ec 30          	sub    rsp,0x30
 c22:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
 c26:	48 89 75 e0          	mov    QWORD PTR [rbp-0x20],rsi
 c2a:	48 89 55 d8          	mov    QWORD PTR [rbp-0x28],rdx
	uint16_t first  = regs[0];
 c2e:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
 c32:	0f b7 00             	movzx  eax,WORD PTR [rax]
 c35:	66 89 45 fc          	mov    WORD PTR [rbp-0x4],ax
	uint16_t second = regs[1];
 c39:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
 c3d:	0f b7 40 02          	movzx  eax,WORD PTR [rax+0x2]
 c41:	66 89 45 fe          	mov    WORD PTR [rbp-0x2],ax

	tickCallback(data);
 c45:	48 8b 55 d8          	mov    rdx,QWORD PTR [rbp-0x28]
 c49:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
 c4d:	48 89 d7             	mov    rdi,rdx
 c50:	ff d0                	call   rax
}
 c52:	90                   	nop
 c53:	c9                   	leave  
 c54:	c3                   	ret    

0000000000000c55 <main>:


int main(int argc, char *argv[]) {
 c55:	55                   	push   rbp
 c56:	48 89 e5             	mov    rbp,rsp
 c59:	48 83 ec 10          	sub    rsp,0x10
 c5d:	89 7d fc             	mov    DWORD PTR [rbp-0x4],edi
 c60:	48 89 75 f0          	mov    QWORD PTR [rbp-0x10],rsi
//	int data;

//	uint16_t regs[3];

	runCode(NULL, _onInt, NULL);
 c64:	ba 00 00 00 00       	mov    edx,0x0
 c69:	48 8d 35 3a fa ff ff 	lea    rsi,[rip+0xfffffffffffffa3a]        # 6aa <_onInt>
 c70:	bf 00 00 00 00       	mov    edi,0x0
 c75:	e8 a0 ff ff ff       	call   c1a <runCode>

	nexti(NULL, 2);
 c7a:	be 02 00 00 00       	mov    esi,0x2
 c7f:	bf 00 00 00 00       	mov    edi,0x0
 c84:	e8 d1 fe ff ff       	call   b5a <nexti>

	readByte(NULL, 0x88);
 c89:	be 88 00 00 00       	mov    esi,0x88
 c8e:	bf 00 00 00 00       	mov    edi,0x0
 c93:	e8 6d ff ff ff       	call   c05 <readByte>
 c98:	b8 00 00 00 00       	mov    eax,0x0
}
 c9d:	c9                   	leave  
 c9e:	c3                   	ret    
 c9f:	90                   	nop

0000000000000ca0 <__libc_csu_init>:
 ca0:	41 57                	push   r15
 ca2:	41 56                	push   r14
 ca4:	49 89 d7             	mov    r15,rdx
 ca7:	41 55                	push   r13
 ca9:	41 54                	push   r12
 cab:	4c 8d 25 fe 10 20 00 	lea    r12,[rip+0x2010fe]        # 201db0 <__frame_dummy_init_array_entry>
 cb2:	55                   	push   rbp
 cb3:	48 8d 2d fe 10 20 00 	lea    rbp,[rip+0x2010fe]        # 201db8 <__init_array_end>
 cba:	53                   	push   rbx
 cbb:	41 89 fd             	mov    r13d,edi
 cbe:	49 89 f6             	mov    r14,rsi
 cc1:	4c 29 e5             	sub    rbp,r12
 cc4:	48 83 ec 08          	sub    rsp,0x8
 cc8:	48 c1 fd 03          	sar    rbp,0x3
 ccc:	e8 77 f8 ff ff       	call   548 <_init>
 cd1:	48 85 ed             	test   rbp,rbp
 cd4:	74 20                	je     cf6 <__libc_csu_init+0x56>
 cd6:	31 db                	xor    ebx,ebx
 cd8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
 cdf:	00 
 ce0:	4c 89 fa             	mov    rdx,r15
 ce3:	4c 89 f6             	mov    rsi,r14
 ce6:	44 89 ef             	mov    edi,r13d
 ce9:	41 ff 14 dc          	call   QWORD PTR [r12+rbx*8]
 ced:	48 83 c3 01          	add    rbx,0x1
 cf1:	48 39 dd             	cmp    rbp,rbx
 cf4:	75 ea                	jne    ce0 <__libc_csu_init+0x40>
 cf6:	48 83 c4 08          	add    rsp,0x8
 cfa:	5b                   	pop    rbx
 cfb:	5d                   	pop    rbp
 cfc:	41 5c                	pop    r12
 cfe:	41 5d                	pop    r13
 d00:	41 5e                	pop    r14
 d02:	41 5f                	pop    r15
 d04:	c3                   	ret    
 d05:	90                   	nop
 d06:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
 d0d:	00 00 00 

0000000000000d10 <__libc_csu_fini>:
 d10:	f3 c3                	repz ret 

Disassembly of section .fini:

0000000000000d14 <_fini>:
 d14:	48 83 ec 08          	sub    rsp,0x8
 d18:	48 83 c4 08          	add    rsp,0x8
 d1c:	c3                   	ret    
